*! version 1.0.1  PR 17Dec97. rev PS 23Dec97 5.25pm* This version looks for a variable called _touse created by stcox* identifying those observations remaining after mark and markout *program define stgtcalcversion 5.0st_isif "$S_E_cmd2"!="stcox" {	error 301}tempname V coef tempvar cmatrix `V' = get(VCE)matrix `coef' = get(_b)local vars : colnames (`coef')local t : char _dta[st_t]local dead : char _dta[st_d]local t0 : char _dta[st_t0]local id : char _dta[st_id]local w  : char _dta[st_w]local wt : char _dta[st_wt]if "`id'"!="" & "`t0'"==""{	di in red "id not currently supported without t0"	exit 198}if "`w'`wt'"!="" {	di in red "weights not currently supported"	exit 198}quietly {	capture confirm var _touse	if _rc==0 {		local if "if _touse==1"	}	if "`dead'"!="" {		local ifdead "if (`dead'!=0 & `dead'!=.)"		if "`if'"!="" { local ifdead "`ifdead' & _touse==1" }		gen byte `c' = !`dead' `if' 	}	else {		gen byte `c' = 0 `if'	/* all dead */		local ifdead "`if'"	}	count `ifdead'	local ndead = _result(1)	matrix `V' = `V'*`ndead'	tempvar hr order mark IND s0 s1	predict `hr' 	local nobs = _N	if "`t0'" != "" {		unabbrev `t0', max(1) 		local t0 "$S_1"		local t0ttl "`t0'"		capture assert `t0'<`t' `if'		if _rc {			di in red "t0(`t0') >= `t' in some obs."			exit 498		}		preserve		tempvar index		gen long `index' = _n		compress `index'		sort `index'		local fn "$S_FN"		tempfile old		save "`old'"		capture keep `if'		keep `vars' `hr' `t' `dead' `t0' `id' $S_E_svn `index' `c'		expand 2		gen byte `mark'=-cond(_n<`nobs',2,cond(`c',3,1))/*			-2=enter -3=censor -1=die	*/		replace `t'=`t0' in 1/`nobs'	}	else {		gen byte `mark'=-cond(`c',3,1)	}	gen  `order' = -`t'	sort $S_E_svn `order' `mark' 	if "${S_E_svn}"!="" {		local S_by "by ${S_E_svn} :"	}	`S_by' gen double `s0'=sum(cond(`mark'==-2,-`hr',`hr'))	by $S_E_svn `order' : replace `s0'=`s0'[_N] if `mark'==-1	gen double `s1' = .	parse "`vars'", parse(" ")	local nv 0	while "`1'"!="" {		local nv = `nv'+1		local var`nv' `1'		tempvar res`nv' GT`nv'		`S_by' replace `s1'=sum(`1'*cond(`mark'==-2,-`hr',`hr'))		by $S_E_svn `order' : replace `s1'=`s1'[_N] if `mark'==-1		gen `res`nv'' = cond(`mark'==-1,(`1'-`s1'/`s0'),.) 		local rvars "`rvars' `res`nv''"		local GTvars "`GTvars' `GT`nv''"		mac shift	}	cap drop GT*	mxv `rvars' `if', mat(`V') gen(`GTvars')	local i 1	while `i'<=`nv' {		quietly replace `GT`i'' = `GT`i''+`coef'[1,`i']		mkname1 `var`i'', prefix(GT)		rename `GT`i'' $S_1		lab var $S_1 "`var`i'' stand. score res."		local i = `i'+1	}	if "`t0'" != "" {		keep if `t'>`t0'		sort `index'		merge `index' using `old'		drop _merge		global S_FN `fn'		restore, not	}}end*! Based on PDS _mxv version 1.0.1  25May1995program def mxvversion 4.0local varlist "req ex"local in "opt"local if "opt"local options "Matrix(string) Generate(string)"parse "`*'"tempname nrow scalar `nrow'=rowsof(`matrix')tempname M vecmatrix `M' = `matrix'matrix colnames `M' = `varlist'parse "`generate'", parse(" ")quietly {	local i 0	while "`1'" !="" {		local i = `i'+1		matrix `vec'=`M'[`i',.]		matrix score `1' = `vec' `if' `in'		mac shift	}}end