*! 1.0.1 NJC 14 Nov 2002program define cij, rclass byable(recall)	version 7	global S_1		/* # obs	*/	global S_3		/* mean		*/	global S_4		/* se of mean	*/	global S_5		/* lower bound	*/	global S_6		/* upper bound	*/	syntax [varlist] [if] [in] [fw] [, Level(integer $S_level)  /*	*/ BY(varlist) beta(numlist min=2 max=2 >0) Total ]	if "`by'"!="" {		/* backwards compatibility */		if _by() {			di in red /*			*/ "by() option may not be combined with by prefix"			exit 190		}		if "`weight'" != "" {			local wgt `"[`weight'`exp']"'		}		if "`level'" != "" {			local level "level(`level')"		}		by `by': cij `varlist' `if' `in' `wgt', `level' `total'		exit	}	if "`total'" != "" & !_by() {		di in red "option total may only be specified with by"		exit 198	}			if `level'<10 | `level'>99 { 		di in red "level() invalid"		exit 198	}	tempvar touse	mark `touse' [`weight'`exp'] `if' `in'	if _by() & _bylastcall() & "`total'"!="" {				/* set alluse for later use */		tempvar alluse				mark `alluse' [`weight'`exp'] `if' `in', noby	}	local weight "[`weight'`exp']"	tempvar BYGRP	if "`beta'" == "" { 		local beta "0.5 0.5"	} 		else local supplied "supplied" 	di	Ci `varlist' `weight' if `touse', level(`level') beta(`beta') `supplied' 	ret add  /* add return values from Ci */	if _by() & _bylastcall() & "`total'"!="" {		di _n in gr _dup(79) "_" _n "-> Total"		if "`level'"!="" {			local level "level(`level')"		}		cij `varlist' if `alluse' `weight', `level' 		return clear		ret add	}end/*	In program Ci, we know the `if' is resolved to a touse variable	and marks out everything except the missing values of the 	variables.  Therefore, we do not reduce it again but just use `if'*/program define Ci, rclass	version 7 	syntax varlist [fw] [if] [, Level(integer $S_level) beta(string) supplied] 	local a : word 1 of `beta' 	local b : word 2 of `beta' 	tempname lb ub	tempvar tousex	local ttl "    Mean"	local tl1 "    Obs "	local txt = cond("`supplied'" != "", "Supplied", "Jeffreys") 	di in smcl in gr _col(56) "{hline 2} `txt' Prior {hline 2}"		#delimit ;	di in smcl in gr "    Variable {c |} `tl1'    `ttl'    Std. Err.       [`level'% Conf. Interval]"	_n "{hline 13}{c +}{hline 61}" ;	#delimit cr	global S_1 0	global S_2 .	global S_3 . 	global S_4 . 	global S_5 . 	global S_6 . 	tokenize `varlist'        while ("`1'"!="") {		local toprt 1		capture confirm string var `1'		if _rc==0 { 			local toprt 0		}		else {			capture assert `1'==0 | `1'==1 | `1'==. `if'			if _rc { 				local toprt 0			}			else { 				sum `1' [`weight'`exp'] `if', meanonly 				local n = r(N)				local k = r(sum)				ret scalar N = `n'				ret scalar mean = `k'/`n'				ret scalar se=sqrt((return(mean)* /*					*/ (1-return(mean)))/`n')				if `k' == 0 { 					scalar `lb' = 0 				} 				else { 				        scalar `lb' = /* */ invFtail(2 * (`k' + `a'), 2 * (`n' - `k' + `b'), (100 + `level') / 200) 			        	scalar `lb' = /* */ ((`k' + `a') * `lb') / (`n' - `k' + `b' + ((`k' + `a') * `lb'))				} 				if `k' == `n' { 					scalar `ub' = 1				} 				else { 				        scalar `ub' = /* */ invFtail(2 * (`k' + `a'), 2 * (`n' - `k' + `b'), (100 - `level') / 200)			        	scalar `ub' = /* */ ((`k' + `a') * `ub') / (`n' - `k' + `b' + ((`k' + `a') * `ub')) 				}				ret scalar lb = `lb'				ret scalar ub = `ub' 				/* double save in S_# and r() */				global S_1 `return(N)'				global S_3 `return(mean)'				global S_4 `return(se)'				global S_5 `return(lb)'				global S_6 `return(ub)'			}			if `toprt' { 				local fmt : format `1'				if substr("`fmt'",-1,1)=="f" { 					local ofmt="%9."+substr("`fmt'",-2,2)				}				else if substr("`fmt'",-2,2)=="fc" {					local ofmt="%9."+substr("`fmt'",-3,3)				}				else	local ofmt "%9.0g"				di in smcl in gr /*				*/ %12s abbrev("`1'",12) " {c |}" _col(14) /*				*/ in yel %8.0f return(N) /*		 		*/ _col(27) `ofmt' return(mean) /*		 		*/ _col(39) `ofmt' return(se) /*		 		*/ _col(55) `ofmt' return(lb) /*		 		*/ _col(67) `ofmt' return(ub) in gr "`mark'"			}		}		mac shift	}endexit